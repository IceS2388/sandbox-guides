= Recommendations
:user_name: 'Misty Williams'
:movie_name: 'Matrix'
:experimental:
:icon: font


== Personalized Product Recommendations With Neo4j

++++
<div class="col-lg-3 ng-scope">
++++

=== Neo4j


+++
</div>
+++

++++
<div class="col-lg-6 ng-scope">
++++
=== Other Resources

+++
</div>
+++

++++
<div class="col-lg-3 ng-scope">
++++
=== The Data


[subs=attributes]
++++
<img src="{img}/openmoviegraph.png" class="img-responsive">
++++

.Data Sources
****
* http://www.omdbapi.com/[Open Movie Database]
* https://grouplens.org/datasets/movielens/[MovieLens]
****


++++
</div>
++++

== Recommendations with neo4j


++++
<div class="col-lg-6 ng-scope">
++++
=== Silo 1

[subs=attributes]
++++
<img src="{img}/silo1.png" class="img-responsive">
++++

++++
</div>
++++

++++
<div class="col-lg-6 ng-scope">
++++

=== Silo 2

[subs=attributes]
.Caption here?
++++
<img src="{img}/silo2.png" class="img-responsive">
++++

++++
</div>
++++

== The Labeled Property Graph Datamodel

++++
<div class="col-lg-3 ng-scope">
++++
=== Elements

* Nodes
- Entities
- Labels
- Properties

++++
</div>
++++

++++
<div class="col-lg-9 ng-scope">
++++

.Caption for the image, explain the data model
[subs=attributes]
++++
<img src="{img}/lpg.png" class="img-responsive">
++++

++++
</div>
++++

== The Open Movie Graph Data Model



++++
<div class="col-lg-3 ng-scope">
++++

=== Data Silos

Explain the two different silos represented here

++++
</div>
++++

++++
<div class="col-lg-9 ng-scope">
++++

.Caption for the image??
[subs=attributes]
++++
<img src="{img}/datamodel.png" class="img-responsive">
++++

++++
</div>
++++

== Intro To Cypher

In order to work with our labeled property graph we need a query language for graphs. 


++++
<div class="col-lg-3 ng-scope">
++++
=== Graph Patterns

Cypher is the query language for graphs and is centered around *graph patterns*. Graph patterns are expressed in Cypher using ASCII-art like syntax. Nodes

++++
</div>
++++

++++
<div class="col-lg-9 ng-scope">
++++

=== Dissecting A Cypher Statement
Let's look a complex Cypher query (don't worry we'll build up our understanding of Cypher as we progress.

[width=100]
|===
| find      | `MATCH (m:Movie)<-[:RATED]-(u:User)`         | Explain match
| filter    | `WHERE m.title CONTAINS "Matrix"`            | Explain filter
| aggregate | `WITH m.title AS movie, COUNT(*) AS reviews` | Explain COUNT
| return    | `RETURN movie, reviews`                      | Explain return
| order     | `ORDER BY reviews DESC;`                     | Explain order by
|===


.Number of reviews for each Matrix movies
[source,cypher]
----
MATCH (m:Movie)<-[:RATED]-(u:User)
WHERE m.title CONTAINS "Matrix"
WITH m.title AS movie, COUNT(*) AS reviews
RETURN movie, reviews
ORDER BY reviews DESC;
----

Click on the block to put the query in the topmost window on the query editor. Hit the triangular icon:play-circle[] button or press kbd:[Ctrl+Enter] to run it and see the resulting visualization.

++++
</div>
++++

== Recommendations

Now let's start generating some recommendations.

There are two basic approaches to recommendations:

* `Content based` - recommend items that are similar to those that a user previously liked.
* `Collaborative filtering` - use the preferences of other users in the network to find items to recommend.

In reality most recommender systems in production are a blend of these two approaches

++++
<div class="col-lg-6 ng-scope">
++++


=== Content Based Filtering

[subs=attributes]
++++
<img src="{img}/content1.png" class="img-responsive">
++++


Looking at the content of products to find products similar to those the user has liked previously.

++++
</div>
++++

++++
<div class="col-lg-6 ng-scope">
++++

=== Collaborative Filtering

[subs=attributes]
++++
<img src="{img}/cf1.png" class="img-responsive">
++++


++++
</div>
++++


== Content Based Filtering

The goal of content based filtering is to find similar items, using attributes of the item. Using our movie data, one way we could define similarlity is movies that have overlapping genres.

[subs=attributes]
++++
<img src="{img}/genres.png" class="img-responsive">
++++

=== Similarity Based On Common Genres

[source,cypher]
----
// Find similar movies by common genres
MATCH (m:Movie) WHERE m.title = "Kung Fu Panda 3"
MATCH (m)-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(rec:Movie)
RETURN rec.title AS recommendation, COUNT(*) AS num ORDER BY num DESC LIMIT 10;
----

=== Content recommendation by overlapping genres

[source,cypher]
----
// Content recommendation by overlapping genres
MATCH (u:User {name: "Misty Williams"})
MATCH (u)-[r:RATED]->(m:Movie)
MATCH (m)-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(rec:Movie)
RETURN rec.title AS recommendation, COUNT(*) AS score ORDER BY score DESC LIMIT 10;
----


=== Only Consider Genres Liked By user

[source,cypher,subs=attributes]
----
MATCH (u:User {name: "Misty Williams"})-[r:RATED]->(m:Movie)
WITH u, avg(r.rating) AS mean

MATCH (u)-[r:RATED]->(m:Movie)-[:IN_GENRE]->(g:Genre)
WHERE r.rating > mean

WITH u, g, COUNT(*) AS score

MATCH (g)<-[:IN_GENRE]-(rec:Movie)
WHERE NOT EXISTS((u)-[:RATED]->(rec))

RETURN rec.title AS recommendation, COLLECT(DISTINCT g.name) AS genres, SUM(score) AS sscore 
ORDER BY sscore DESC LIMIT 10
----

=== Weighted Content Algorithm

[source,cypher,subs=attributes]
----
// Find similar movies by common genres
MATCH (m:Movie) WHERE m.title = "Wizard of Oz, The"
MATCH (m)-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(rec:Movie)

WITH m, rec, COUNT(*) AS gs

OPTIONAL MATCH (m)<-[:ACTED_IN]-(a:Actor)-[:ACTED_IN]->(rec)
WITH m, rec, gs, COUNT(a) AS as

OPTIONAL MATCH (m)<-[:DIRECTED]-(d:Director)-[:DIRECTED]->(rec)
WITH m, rec, gs, as, COUNT(d) AS ds

RETURN rec.title AS recommendation, (5*gs)+(3*as)+(4*ds) AS score ORDER BY score DESC LIMIT 100
----

== Content based similarity metrics

TODO: threshold of overlapping genres?


++++
<div class="col-lg-3 ng-scope">
++++

=== Jaccard index

[subs=attributes]
++++
<img src="{img}/jaccard.png" class="img-responsive">
++++

Some blurd about Jaccard index.

++++
</div>
++++


++++
<div class="col-lg-9 ng-scope">
++++

[source,cypher]
----
MATCH (m:Movie {title: "Matrix, The"})-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(other:Movie)
WITH m, other, COUNT(g) AS intersection, COLLECT(g.name) AS i
MATCH (m)-[:IN_GENRE]->(mg:Genre)
WITH m,other, intersection,i, COLLECT(mg) AS s1
MATCH (other)-[:IN_GENRE]->(og:Genre)
WITH m,other,intersection,i, s1, COLLECT(og) AS s2

WITH m,other,intersection,s1,s2

WITH m,other,intersection,s1+filter(x IN s2 WHERE NOT x IN s1) AS union, s1, s2

RETURN s1, s2, m, other, ((1.0*intersection)/SIZE(union)) AS jaccard ORDER BY jaccard DESC LIMIT 100
//RETURN * ORDER BY intersection DESC LIMIT 10
----

++++
</div>
++++
== Collaborative Filtering - Movie ratings

// TODO: graphic that shows ratings (arrows with data points)

=== Show all ratings by Misty Williams

[source,cypher]
----
// Show all ratings by Misty Williams
MATCH (u:User {name: "Misty Williams"})
MATCH (u)-[r:RATED]->(m:Movie)
RETURN *;
----

=== Find Misty's average rating

[source,cypher]
----
// Show all ratings by Misty Williams
MATCH (u:User {name: "Misty Williams"})
MATCH (u)-[r:RATED]->(m:Movie)
RETURN avg(r.rating) AS average;
----

=== What are the movies that Misty liked more than average?

[source,cypher]
----
// What are the movies that Misty liked more than average?
MATCH (u:User {name: "Misty Williams"})
MATCH (u)-[r:RATED]->(m:Movie)
WITH u, avg(r.rating) AS average
MATCH (u)-[r:RATED]->(m:Movie)
WHERE r.rating > average
RETURN *;
----

// TODO: we else liked movies that Misty rated highly

== Finding similar users

* Jaccard Similarity
* Pearson correlation
* Cosine distance


== Collaborative Filtering - Similarity Metrics

++++
<div class="col-lg-3 ng-scope">
++++
=== Cosine Distance

[subs=attributes]
++++
<img src="{img}/cosine.png" class="img-responsive">
++++

Blurb about cosine distance. Something about number of dimensions? Scale?

++++
</div>
++++


++++
<div class="col-lg-9 ng-scope">
++++

[source,cypher,subs=attributes]
----
// Most similar users using Cosine similarity
MATCH (p1:User {name: {user_name}})-[x:RATED]->(m:Movie)<-[y:RATED]-(p2:User)
WITH SUM(x.rating * y.rating) AS xyDotProduct,
SQRT(REDUCE(xDot = 0.0, a IN COLLECT(x.rating) | xDot + a^2)) AS xLength,
SQRT(REDUCE(yDot = 0.0, b IN COLLECT(y.rating) | yDot + b^2)) AS yLength,
p1, p2
RETURN p1.name, p2.name, xyDotProduct / (xLength * yLength) AS sim 
ORDER BY sim DESC LIMIT 100;
----

++++
</div>
++++

== Collaborative Filtering - Similarity Metrics

=== Pearson similarity

++++
<div class="col-lg-3 ng-scope">
++++

[subs=attributes]
++++
<img src="{img}/pearson.png" class="img-responsive">
++++

Blurd about Pearson similarity. Benefit is that it can accomodate stochastic means across users. Scale (-1 to +1?) 

++++
</div>
++++

++++
<div class="col-lg-9 ng-scope">
++++


.Code caption goes here?
[source,cypher]
----
MATCH (u1:User {name:"Misty Williams"})-[r:RATED]->(m:Movie)
WITH u1, avg(r.rating) AS u1_mean

MATCH (u1)-[r1:RATED]->(m:Movie)<-[r2:RATED]-(u2) 
WITH u1, u1_mean, u2, COLLECT({r1: r1, r2: r2}) AS ratings WHERE size(ratings) > 10

MATCH (u2)-[r:RATED]->(m:Movie)
WITH u1, u1_mean, u2, avg(r.rating) AS u2_mean, ratings

UNWIND ratings AS r

WITH sum( (r.r1.rating-u1_mean) * (r.r2.rating-u2_mean) ) AS nom,
     sqrt( sum( (r.r1.rating - u1_mean)^2) * sum( (r.r2.rating - u2_mean) ^2)) AS denom, 
     u1, u2 WHERE denom <> 0

RETURN u1.name, u2.name, nom/denom AS pearson 
ORDER BY pearson DESC LIMIT 100
----

++++
</div>
++++

== Collaborative Filtering - kNN Recommendations


++++
<div class="col-lg-3 ng-scope">
++++

=== kNN

* Neigborhood based recommendation

++++
</div>
++++


++++
<div class="col-lg-9 ng-scope">
++++

.Code comment block goes here?
[source,cypher,subs=attributes]
----
MATCH (u1:User {name:"Cynthia Freeman"})-[r:RATED]->(m:Movie)
WITH u1, avg(r.rating) AS u1_mean

MATCH (u1)-[r1:RATED]->(m:Movie)<-[r2:RATED]-(u2) 
WITH u1, u1_mean, u2, COLLECT({r1: r1, r2: r2}) AS ratings WHERE size(ratings) > 10

MATCH (u2)-[r:RATED]->(m:Movie)
WITH u1, u1_mean, u2, avg(r.rating) AS u2_mean, ratings

UNWIND ratings AS r

WITH sum( (r.r1.rating-u1_mean) * (r.r2.rating-u2_mean) ) AS nom,
     sqrt( sum( (r.r1.rating - u1_mean)^2) * sum( (r.r2.rating - u2_mean) ^2)) AS denom, 
     u1, u2 WHERE denom <> 0

WITH u1, u2, nom/denom AS pearson 
ORDER BY pearson DESC LIMIT 10

MATCH (u2)-[r:RATED]->(m:Movie) WHERE NOT EXISTS( (u1)-[:RATED]->(m) )

RETURN m.title, SUM( pearson * r.rating) AS score
ORDER BY score DESC LIMIT 25
----

++++
</div>
++++

== Group Recommender System

Is it possible to make recommendations to a group of users? In the context of this example, can we recommend a restaurant that takes into account information about the individual users likes and dislikes? There are many strategies for aggregating a group of users preferences. This is an example of the application of "Social Choice Theory". For example:

* Plurality voting
* Average
* Multiplicative
* Borda Count
* Least misery
* Most Pleasure

== Further Resources

A BUNCH OF CALL TO ACTION STUFF HERE!!
