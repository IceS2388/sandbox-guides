= Recommendations
:user_name: 'Misty Williams'
:movie_name: 'Matrix'
:experimental:
:icon: font


== Personalized Recommendations With Neo4j

++++
<div class="col-lg-3 ng-scope">
++++

=== Neo4j


+++
</div>
+++

++++
<div class="col-lg-6 ng-scope">
++++
=== Other Resources

+++
</div>
+++

++++
<div class="col-lg-3 ng-scope">
++++
=== The Data


[subs=attributes]
++++
<img src="{img}/openmoviegraph.png" class="img-responsive">
++++

.Data Sources
****
* http://www.omdbapi.com/[Open Movie Database]
* https://grouplens.org/datasets/movielens/[MovieLens]
****


++++
</div>
++++

== Recommendations with neo4j


++++
<div class="col-lg-6 ng-scope">
++++
=== Silo 1

[subs=attributes]
++++
<img src="{img}/silo1.png" class="img-responsive">
++++

++++
</div>
++++

++++
<div class="col-lg-6 ng-scope">
++++

=== Silo 2

[subs=attributes]
.Caption here?
++++
<img src="{img}/silo2.png" class="img-responsive">
++++

++++
</div>
++++

== The Labeled Property Graph Datamodel

++++
<div class="col-lg-3 ng-scope">
++++
=== Elements

* Nodes
- Entities
- Labels
- Properties

++++
</div>
++++

++++
<div class="col-lg-9 ng-scope">
++++

.Caption for the image, explain the data model
[subs=attributes]
++++
<img src="{img}/lpg.png" class="img-responsive">
++++

++++
</div>
++++

== The Open Movie Graph Data Model



++++
<div class="col-lg-3 ng-scope">
++++

=== Data Silos

Explain the two different silos represented here

++++
</div>
++++

++++
<div class="col-lg-9 ng-scope">
++++

.Caption for the image??
[subs=attributes]
++++
<img src="{img}/datamodel.png" class="img-responsive">
++++

++++
</div>
++++

== Intro To Cypher

In order to work with our labeled property graph we need a query language for graphs. 


++++
<div class="col-lg-3 ng-scope">
++++
=== Graph Patterns

Cypher is the query language for graphs and is centered around *graph patterns*. Graph patterns are expressed in Cypher using ASCII-art like syntax. Nodes

++++
</div>
++++

++++
<div class="col-lg-9 ng-scope">
++++

=== Dissecting A Cypher Statement
Let's look a complex Cypher query (don't worry we'll build up our understanding of Cypher as we progress.

[width=100]
|===
| find      | `MATCH (m:Movie)<-[:RATED]-(u:User)`         | Explain match
| filter    | `WHERE m.title CONTAINS "Matrix"`            | Explain filter
| aggregate | `WITH m.title AS movie, COUNT(*) AS reviews` | Explain COUNT
| return    | `RETURN movie, reviews`                      | Explain return
| order     | `ORDER BY reviews DESC;`                     | Explain order by
|===


.Number of reviews for each Matrix movies
[source,cypher]
----
MATCH (m:Movie)<-[:RATED]-(u:User)
WHERE m.title CONTAINS "Matrix"
WITH m.title AS movie, COUNT(*) AS reviews
RETURN movie, reviews
ORDER BY reviews DESC;
----

Click on the block to put the query in the topmost window on the query editor. Hit the triangular icon:play-circle[] button or press kbd:[Ctrl+Enter] to run it and see the resulting visualization.

++++
</div>
++++

== Recommendations

Now let's start generating some recommendations.

There are two basic approaches to recommendations:

* `Content based` - recommend items that are similar to those that a user previously liked.
* `Collaborative filtering` - use the preferences of other users in the network to find items to recommend.

In reality most recommender systems in production are a blend of these two approaches

== Similar Movies

[source,cypher]
----
// Find movies similar to Matrix movies
MATCH (m:Movie) WHERE m.title CONTAINS "Matrix"
MATCH (m)-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(rec:Movie)
RETURN rec, count(*) AS num ORDER BY num DESC LIMIT 10;
----

== Content recommendation by overlapping genres

image::{img}/genres.png[]

[source,cypher]
----
// Content recommendation by overlapping genres
MATCH (u:User {name: "Misty Williams"})
MATCH (u)-[r:RATED]->(m:Movie)
MATCH (m)-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(rec:Movie)
RETURN rec.title, COUNT(*) AS score ORDER BY score DESC LIMIT 10;
----

== Content based similarity metrics

TODO: threshold of overlapping genres?

=== Jaccard index

image::{img}/jaccard.png[]

[source,cypher]
----
// TODO: Jaccard for genre similarity

----

== Movie ratings


=== Show all ratings by Misty Williams

[source,cypher]
----
// Show all ratings by Misty Williams
MATCH (u:User {name: "Misty Williams"})
MATCH (u)-[r:RATED]->(m:Movie)
RETURN *;
----

=== Find Misty's average rating

[source,cypher]
----
// Show all ratings by Misty Williams
MATCH (u:User {name: "Misty Williams"})
MATCH (u)-[r:RATED]->(m:Movie)
RETURN avg(r.rating) AS average;
----

=== What are the movies that Misty liked more than average?

[source,cypher]
----
// What are the movies that Misty liked more than average?
MATCH (u:User {name: "Misty Williams"})
MATCH (u)-[r:RATED]->(m:Movie)
WITH u, avg(r.rating) AS average
MATCH (u)-[r:RATED]->(m:Movie)
WHERE r.rating > average
RETURN *;
----

== Finding similar users

* Jaccard Similarity
* Pearson correlation
* Cosine distance

== Jaccard Similarity

image::{img}/jaccard.png[]

[source,cypher]
----
TODO: jaccard
----

== Pearson similarity

image::{img}/pearson.png[]

[source,cypher]
----
MATCH (u1:User), (u2:User) WHERE u1 <> u2
MATCH (u1)-[r:Reviewed]->(rest) WITH 1.0*sum(r.stars)/count(r) AS u1_mean, u1, u2
MATCH (u2)-[r:Reviewed]->(rest) WITH 1.0*sum(r.stars)/count(r) AS u2_mean, u1_mean, u1, u2
MATCH (u1)-[r1:Reviewed]->(rest)<-[r2:Reviewed]-(u2) WITH sum((r1.stars-u1_mean)*(r2.stars-u2_mean)) AS num, sqrt(sum((r1.stars-u1_mean)^2) * sum((r2.stars-u2_mean)^2)) AS denom, u1, u2
WHERE denom <>0 CREATE (u1)<-[:Similarity{coef: (num/denom)}]-(u2) 
//WHERE denom <> 0 RETURN (num)/(denom) as pearson, u1, u2
----

== Cosine similarity

image::{img}/cosine.png[]

[source,cypher]
----
// Most similar users using Cosine similarity
MATCH (p1:User {name: "{user_name}"})-[x:RATED]->(m:Movie)<-[y:RATED]-(p2:User)
WITH SUM(x.rating * y.rating) AS xyDotProduct,
SQRT(REDUCE(xDot = 0.0, a IN COLLECT(x.rating) | xDot + a^2)) AS xLength,
SQRT(REDUCE(yDot = 0.0, b IN COLLECT(y.rating) | yDot + b^2)) AS yLength,
p1, p2
RETURN p1, p2, xyDotProduct / (xLength * yLength) AS sim ORDER BY sim DESC;
----

== kNN

* Neigborhood based recommendation

[source,cypher,subs=attributes]
----

----

== Group Recommender System

Is it possible to make recommendations to a group of users? In the context of this example, can we recommend a restaurant that takes into account information about the individual users likes and dislikes? There are many strategies for aggregating a group of users preferences. This is an example of the application of "Social Choice Theory". For example:

* Plurality voting
* Average
* Multiplicative
* Borda Count
* Least misery
* Most Pleasure
