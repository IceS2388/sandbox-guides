= Recommendations
:user_name: 'Misty Williams'
:movie_name: 'Matrix'


== The Open Movie Graph

image::{img}/openmoviegraph.png[]

== Recommendations with neo4j

image::{img}/datamodel.png[]

[source,cypher]
----
CALL db.schema();
----

== Intro To Cypher

Cypher is the query language for graphs.

=== MATCH

=== Graph Patterns

=== WHERE predicates


That's just a basic introduction to Cypher, we can do a log more co

== Recommendations

Now let's start generating some recommendations.

There are two basic approaches to recommendations:

* `Content based` - recommend items that are similar to those that a user previously liked.
* `Collaborative filtering` - use the preferences of other users in the network to find items to recommend.

In reality most recommender systems in production are a blend of these two approaches

== Similar Movies

[source,cypher]
----
// Find movies similar to Matrix movies
MATCH (m:Movie) WHERE m.title CONTAINS "Matrix"
MATCH (m)-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(rec:Movie)
RETURN rec, count(*) AS num ORDER BY num DESC LIMIT 10;
----

== Content recommendation by overlapping genres

image::{img}/genres.png[]

[source,cypher]
----
// Content recommendation by overlapping genres
MATCH (u:User {name: "Misty Williams"})
MATCH (u)-[r:RATED]->(m:Movie)
MATCH (m)-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(rec:Movie)
RETURN rec.title, COUNT(*) AS score ORDER BY score DESC LIMIT 10;
----

== Content based similarity metrics

TODO: threshold of overlapping genres?

=== Jaccard index

image::{img}/jaccard.png[]

[source,cypher]
----
// TODO: Jaccard for genre similarity

----

== Movie ratings


=== Show all ratings by Misty Williams

[source,cypher]
----
// Show all ratings by Misty Williams
MATCH (u:User {name: "Misty Williams"})
MATCH (u)-[r:RATED]->(m:Movie)
RETURN *;
----

=== Find Misty's average rating

[source,cypher]
----
// Show all ratings by Misty Williams
MATCH (u:User {name: "Misty Williams"})
MATCH (u)-[r:RATED]->(m:Movie)
RETURN avg(r.rating) AS average;
----

=== What are the movies that Misty liked more than average?

[source,cypher]
----
// What are the movies that Misty liked more than average?
MATCH (u:User {name: "Misty Williams"})
MATCH (u)-[r:RATED]->(m:Movie)
WITH u, avg(r.rating) AS average
MATCH (u)-[r:RATED]->(m:Movie)
WHERE r.rating > average
RETURN *;
----

== Finding similar users

* Jaccard Similarity
* Pearson correlation
* Cosine distance

== Jaccard Similarity

image::{img}/jaccard.png[]

[source,cypher]
----
TODO: jaccard
----

== Pearson similarity

image::{img}/pearson.png[]

[source,cypher]
----
MATCH (u1:User), (u2:User) WHERE u1 <> u2
MATCH (u1)-[r:Reviewed]->(rest) WITH 1.0*sum(r.stars)/count(r) AS u1_mean, u1, u2
MATCH (u2)-[r:Reviewed]->(rest) WITH 1.0*sum(r.stars)/count(r) AS u2_mean, u1_mean, u1, u2
MATCH (u1)-[r1:Reviewed]->(rest)<-[r2:Reviewed]-(u2) WITH sum((r1.stars-u1_mean)*(r2.stars-u2_mean)) AS num, sqrt(sum((r1.stars-u1_mean)^2) * sum((r2.stars-u2_mean)^2)) AS denom, u1, u2
WHERE denom <>0 CREATE (u1)<-[:Similarity{coef: (num/denom)}]-(u2) 
//WHERE denom <> 0 RETURN (num)/(denom) as pearson, u1, u2
----

== Cosine similarity

image::{img}/cosine.png[]

[source,cypher]
----
// Most similar users using Cosine similarity
MATCH (p1:User {name: "{user_name}"})-[x:RATED]->(m:Movie)<-[y:RATED]-(p2:User)
WITH SUM(x.rating * y.rating) AS xyDotProduct,
SQRT(REDUCE(xDot = 0.0, a IN COLLECT(x.rating) | xDot + a^2)) AS xLength,
SQRT(REDUCE(yDot = 0.0, b IN COLLECT(y.rating) | yDot + b^2)) AS yLength,
p1, p2
RETURN p1, p2, xyDotProduct / (xLength * yLength) AS sim ORDER BY sim DESC;
----

== kNN

* Neigborhood based recommendation

[source,cypher,subs=attributes]
----

----

== Group Recommender System

Is it possible to make recommendations to a group of users? In the context of this example, can we recommend a restaurant that takes into account information about the individual users likes and dislikes? There are many strategies for aggregating a group of users preferences. This is an example of the application of "Social Choice Theory". For example:

* Plurality voting
* Average
* Multiplicative
* Borda Count
* Least misery
* Most Pleasure
